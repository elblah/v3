Index: poc/aicoder/v3/aicoder/core/aicoder.py
==================================================================
--- poc/aicoder/v3/aicoder/core/aicoder.py
+++ poc/aicoder/v3/aicoder/core/aicoder.py
@@ -20,11 +20,10 @@
 from aicoder.core.stream_processor import StreamProcessor
 from aicoder.core.session_manager import SessionManager
 from aicoder.core.prompt_builder import PromptBuilder
 from aicoder.core.socket_server import SocketServer
 from aicoder.utils.log import LogUtils, LogOptions
-from aicoder.type_defs.message_types import AssistantMessage
 from aicoder.utils.stdin_utils import read_stdin_as_string
 
 
 class AICoder:
     """Main AI Coder application class"""
@@ -36,11 +35,11 @@
 
         # Core components
         self.stats = Stats()
         self.message_history = MessageHistory(self.stats)
         self.tool_manager = ToolManager(self.stats)
-        self.streaming_client = StreamingClient(self.stats, self.tool_manager, self.message_history)
+        self.streaming_client = StreamingClient(self.stats, self.tool_manager)
         self.context_bar = ContextBar()
         self.input_handler = InputHandler(
             self.context_bar, self.stats, self.message_history
         )
         self.compaction_service = CompactionService(None)
@@ -239,17 +238,16 @@
             message: Dictionary containing assistant message with optional tool_calls
             
         Returns:
             List of tool execution results
         """
-        # Convert to proper AssistantMessage format
-        from aicoder.type_defs.message_types import AssistantMessage as AICoderAssistantMessage
-        
-        assistant_message = AICoderAssistantMessage(
-            content=message.get("content", ""),
-            tool_calls=message.get("tool_calls", [])
-        )
+        # Use dict for message
+                
+        assistant_message = {
+            "content": message.get("content", ""),
+            "tool_calls": message.get("tool_calls", [])
+        }
         
         # Add the message to history using proper method
         self.message_history.add_assistant_message(assistant_message)
         
         # Execute tool calls if present

Index: poc/aicoder/v3/aicoder/core/commands/load.py
==================================================================
--- poc/aicoder/v3/aicoder/core/commands/load.py
+++ poc/aicoder/v3/aicoder/core/commands/load.py
@@ -61,15 +61,10 @@
 
         return CommandResult(should_quit=False, run_api_call=False)
 
     def _convert_to_message_objects(self, messages_raw):
         """Convert dictionary messages to Message objects"""
-        from aicoder.type_defs.message_types import (
-            Message,
-            MessageRole,
-            MessageToolCall,
-        )
 
         messages = []
         for msg_dict in messages_raw:
             role_str = msg_dict.get("role")
             if not role_str:
@@ -86,22 +81,22 @@
             tool_calls = None
             if "tool_calls" in msg_dict and msg_dict["tool_calls"]:
                 tool_calls = []
                 for tc in msg_dict["tool_calls"]:
                     tool_calls.append(
-                        MessageToolCall(
-                            id=tc.get("id", ""),
-                            type=tc.get("type", "function"),
-                            function=tc.get("function", {}),
-                            index=tc.get("index"),
-                        )
+                        {
+                            "id": tc.get("id", ""),
+                            "type": tc.get("type", "function"),
+                            "function": tc.get("function", {}),
+                            "index": tc.get("index"),
+                        }
                     )
 
-            message = Message(
-                role=role,
-                content=msg_dict.get("content"),
-                tool_calls=tool_calls,
-                tool_call_id=msg_dict.get("tool_call_id"),
-            )
+            message = {
+                "role": role,
+                "content": msg_dict.get("content"),
+                "tool_calls": tool_calls,
+                "tool_call_id": msg_dict.get("tool_call_id"),
+            }
             messages.append(message)
 
         return messages

Index: poc/aicoder/v3/aicoder/core/commands/memory.py
==================================================================
--- poc/aicoder/v3/aicoder/core/commands/memory.py
+++ poc/aicoder/v3/aicoder/core/commands/memory.py
@@ -113,14 +113,13 @@
                     if role == "system":
                         self.context.message_history.add_system_message(content)
                     elif role == "user":
                         self.context.message_history.add_user_message(content)
                     elif role == "assistant":
-                        from aicoder.type_defs.message_types import AssistantMessage
 
                         self.context.message_history.add_assistant_message(
-                            AssistantMessage(content=content, tool_calls=tool_calls)
+                            {"content": content, "tool_calls": tool_calls}
                         )
                     elif role == "tool":
                         self.context.message_history.add_tool_results(
                             [
                                 {

Index: poc/aicoder/v3/aicoder/core/message_history.py
==================================================================
--- poc/aicoder/v3/aicoder/core/message_history.py
+++ poc/aicoder/v3/aicoder/core/message_history.py
@@ -1,23 +1,16 @@
 """Message history management for AI Coder
 Following TypeScript patterns exactly
 """
 
 import json
-from typing import List, Optional, TYPE_CHECKING
-from dataclasses import dataclass
-
-from aicoder.type_defs.message_types import (
-    Message,
-    MessageRole,
-    AssistantMessage,
-    ToolResultData,
-)
+from typing import List, Optional, TYPE_CHECKING, Dict, Any
+
+
 
 
 # Import ToolResult from types package
-from aicoder.type_defs.tool_types import ToolResult
 
 
 from aicoder.core.stats import Stats
 from aicoder.utils.log import LogUtils
 
@@ -36,30 +29,30 @@
     """Simple message storage with delegated compaction logic"""
 
     def __init__(self, stats: Stats, api_client: Optional["StreamingClient"] = None):
         self.stats = stats
         self.api_client = api_client
-        self.messages: List[Message] = []
-        self.initial_system_prompt: Optional[Message] = None
+        self.messages: List[Dict[str, Any]] = []
+        self.initial_system_prompt: Optional[Dict[str, Any]] = None
         self.is_compacting = False
 
     def set_api_client(self, api_client: "StreamingClient") -> None:
         """Set API client for compaction"""
         self.api_client = api_client
 
     def add_system_message(self, content: str) -> None:
         """Add a system message"""
-        message = Message(role="system", content=content)
+        message = {"role": "system", "content": content}
         self.messages.append(message)
         self.estimate_context()
 
         if not self.initial_system_prompt:
             self.initial_system_prompt = message
 
     def add_user_message(self, content: str) -> None:
         """Add a user message"""
-        message = Message(role="user", content=content)
+        message = {"role": "user", "content": content}
         self.messages.append(message)
         self.stats.increment_messages_sent()
         # Update context size estimate
         self.estimate_context()
 
@@ -100,31 +93,27 @@
             insertion_index = last_assistant_index + 1
         elif last_user_index != -1:
             insertion_index = last_user_index + 1
         
         # Create and insert the user message
-        user_message = Message(role="user", content=content)
+        user_message = {"role": "user", "content": content}
         self.messages.insert(insertion_index, user_message)
         self.stats.increment_messages_sent()
         # Update context size estimate
         self.estimate_context()
 
-    def add_assistant_message(self, message: AssistantMessage) -> None:
+    def add_assistant_message(self, message: Dict[str, Any]) -> None:
         """Add an assistant message"""
-        assistant_message = Message(
-            role="assistant",
-            content=message.get("content"),
-            tool_calls=message.get("tool_calls"),
-        )
+        assistant_message = {"role": "assistant", "content": message.get("content"), "tool_calls": message.get("tool_calls")}
         self.messages.append(assistant_message)
         # Update context size estimate
         self.estimate_context()
 
     def add_tool_results(self, tool_results) -> None:
         """Add tool results - accepts both dicts and objects"""
         # Ensure tool_results is iterable
-        if isinstance(tool_results, (dict, ToolResult)) or not hasattr(
+        if isinstance(tool_results, dict) or not hasattr(
             tool_results, "__iter__"
         ):
             tool_results = [tool_results]
 
         for result in tool_results:
@@ -134,31 +123,31 @@
                 content = result.get("content")
             else:
                 tool_call_id = getattr(result, "tool_call_id", None)
                 content = getattr(result, "content", None)
 
-            tool_message = Message(
-                role="tool", content=content, tool_call_id=tool_call_id
-            )
+            tool_message = {
+                "role": "tool", "content": content, "tool_call_id": tool_call_id
+            }
             self.messages.append(tool_message)
         # Update context size estimate
         self.estimate_context()
 
-    def get_messages(self) -> List[Message]:
+    def get_messages(self) -> List[Dict[str, Any]]:
         """Get all messages"""
         return self.messages.copy()
 
-    def get_chat_messages(self) -> List[Message]:
+    def get_chat_messages(self) -> List[Dict[str, Any]]:
         """Get chat messages (excluding system messages)"""
         return [msg for msg in self.messages if msg.get("role") != "system"]
 
-    def replace_messages(self, new_messages: List[Message]) -> None:
+    def replace_messages(self, new_messages: List[Dict[str, Any]]) -> None:
         """Replace all messages with new list"""
         self.messages = new_messages
         self.estimate_context()
 
-    def set_messages(self, new_messages: List[Message]) -> None:
+    def set_messages(self, new_messages: List[Dict[str, Any]]) -> None:
         """Directly set messages (useful for loading sessions and compaction)"""
         self.messages = list(new_messages)  # Make a copy
         self.estimate_context()
 
     def estimate_context(self) -> None:
@@ -185,11 +174,11 @@
         # Restore the initial system prompt if it exists
         if system_prompt:
             self.messages.append(system_prompt)
             self.estimate_context()
 
-    def set_messages(self, messages: List[Message]) -> None:
+    def set_messages(self, messages: List[Dict[str, Any]]) -> None:
         """Set messages (for loading)"""
         self.messages = messages.copy()
         self.estimate_context()
 
     def get_message_count(self) -> int:
@@ -198,11 +187,11 @@
 
     def get_chat_message_count(self) -> int:
         """Get chat message count (excluding system)"""
         return len(self.get_chat_messages())
 
-    def get_initial_system_prompt(self) -> Optional[Message]:
+    def get_initial_system_prompt(self) -> Optional[Dict[str, Any]]:
         """Get the initial system prompt"""
         return self.initial_system_prompt
 
     def increment_compaction_count(self) -> None:
         """Increment compaction counter"""
@@ -280,11 +269,11 @@
             else:
                 in_user_message = False
 
         return rounds
 
-    def get_tool_result_messages(self) -> List[Message]:
+    def get_tool_result_messages(self) -> List[Dict[str, Any]]:
         """Get all tool result messages"""
         return [msg for msg in self.messages if msg.get("role") == "tool"]
 
     def get_tool_call_stats(self) -> dict:
         """Get tool call statistics"""

Index: poc/aicoder/v3/aicoder/core/session_manager.py
==================================================================
--- poc/aicoder/v3/aicoder/core/session_manager.py
+++ poc/aicoder/v3/aicoder/core/session_manager.py
@@ -5,11 +5,10 @@
 
 from typing import Dict, Any, List
 
 from aicoder.core.config import Config
 from aicoder.utils.log import LogUtils, LogOptions
-from aicoder.type_defs.message_types import AssistantMessage
 
 
 class SessionManager:
     """Handles the main AI session processing workflow"""
 
@@ -92,11 +91,11 @@
         )
 
         # Handle error case by adding to message history
         if result.get("error"):
             self.message_history.add_assistant_message(
-                AssistantMessage(content=f"[API Error: {result['error']}]")
+                {"content": f"[API Error: {result['error']}]"}
             )
 
         return result
 
     def _validate_and_process_tool_calls(
@@ -111,51 +110,46 @@
         if not valid_tool_calls:
             LogUtils.error("No valid tool calls to execute")
             return False
 
         # Add assistant message with tool calls
-        from aicoder.type_defs.message_types import AssistantMessage, MessageToolCall
-
         tool_calls_for_message = []
         for i, call in enumerate(valid_tool_calls):
             tool_calls_for_message.append(
-                MessageToolCall(
-                    id=call.get("id"),
-                    type=call.get("type", "function"),
-                    function={
+                {
+                    "id": call.get("id"),
+                    "type": call.get("type", "function"),
+                    "function": {
                         "name": call.get("function", {}).get("name"),
                         "arguments": call.get("function", {}).get("arguments"),
                     },
-                    index=i,
-                )
+                    "index": i,
+                }
             )
 
         self.message_history.add_assistant_message(
-            AssistantMessage(
-                content=full_response or "I'll help you with that.",
-                tool_calls=tool_calls_for_message,
-            )
+            {
+                "content": full_response or "I'll help you with that.",
+                "tool_calls": tool_calls_for_message,
+            }
         )
 
         self.tool_executor.execute_tool_calls(valid_tool_calls)
         return True
 
     def _handle_post_processing(self, has_tool_calls: bool) -> None:
         """Handle post-processing after AI response"""
+        # Check if user requested guidance mode (stop after current tool)
+        if self.tool_executor.is_guidance_mode():
+            LogUtils.success("[*] Guidance mode: Your turn - tell the AI how to proceed")
+            self.tool_executor.clear_guidance_mode()
+            return
+
         if has_tool_calls and self.is_processing and self.message_history.should_auto_compact():
             self._perform_auto_compaction()
 
-        # Check if user requested guidance mode
         if has_tool_calls and self.is_processing:
-            if hasattr(self.tool_executor, 'is_guidance_mode') and self.tool_executor.is_guidance_mode():
-                # User requested guidance with + modifier - stop processing
-                self.tool_executor.clear_guidance_mode()
-                LogUtils.print(
-                    f"\n{Config.colors['cyan']}[*] Guidance mode: Returning to prompt for additional input{Config.colors['reset']}"
-                )
-                return  # Stop recursive processing
-                
             # Continue processing for recursive tool calls
             self.process_with_ai()
 
     def _handle_processing_error(self, error: Exception) -> None:
         """Handle processing errors"""
@@ -163,22 +157,20 @@
 
     def _handle_empty_response(self, full_response: str) -> None:
         """Handle empty response from AI"""
         if full_response and full_response.strip() != "":
             # AI provided text response but no tools
-            from aicoder.type_defs.message_types import AssistantMessage
 
             self.message_history.add_assistant_message(
-                AssistantMessage(content=full_response)
+                {"content": full_response}
             )
             print("")
         else:
             # AI provided no text response (this is normal when AI has nothing to say)
             # Add a minimal message to show AI responded, then continue
-            from aicoder.type_defs.message_types import AssistantMessage
 
-            self.message_history.add_assistant_message(AssistantMessage(content=""))
+            self.message_history.add_assistant_message({"content": ""})
             print("")
 
     def _validate_tool_calls(self, tool_calls: dict) -> list:
         """Validate tool calls"""
         return [
@@ -188,16 +180,18 @@
         ]
 
     def _force_compaction(self) -> None:
         """Force compaction of messages"""
         try:
-            self.message_history.compact_memory()
+            if self.compaction_service:
+                self.compaction_service.force_compact(self.message_history)
         except Exception as e:
             LogUtils.error(f"Force compaction failed: {e}")
 
     def _perform_auto_compaction(self) -> None:
         """Perform automatic compaction"""
         try:
-            self.message_history.compact_memory()
+            if self.compaction_service:
+                self.compaction_service.compact_messages(self.message_history)
         except Exception as e:
             if Config.debug():
                 LogUtils.warn(f"[!] Auto-compaction failed: {e}")

Index: poc/aicoder/v3/aicoder/core/stats.py
==================================================================
--- poc/aicoder/v3/aicoder/core/stats.py
+++ poc/aicoder/v3/aicoder/core/stats.py
@@ -3,11 +3,10 @@
 Ported exactly from TypeScript version
 Stateful: class needed for maintaining counters
 """
 
 from typing import List, Dict, Any
-from aicoder.type_defs.api_types import ApiUsage
 
 
 class Stats:
     """
     Statistics tracking for AI Coder
@@ -105,11 +104,11 @@
         Store last user prompt
         Ported exactly from TS version
         """
         self.last_user_prompt = prompt
 
-    def add_usage_info(self, usage: ApiUsage) -> None:
+    def add_usage_info(self, usage: Dict[str, Any]) -> None:
         """
         Add usage info
         Ported exactly from TS version
         """
         import time

Index: poc/aicoder/v3/aicoder/core/stream_processor.py
==================================================================
--- poc/aicoder/v3/aicoder/core/stream_processor.py
+++ poc/aicoder/v3/aicoder/core/stream_processor.py
@@ -36,36 +36,36 @@
                         "full_response": full_response,
                         "accumulated_tool_calls": accumulated_tool_calls,
                     }
 
                 # Update token stats if present
-                if hasattr(chunk, "usage") and chunk.usage:
-                    self.streaming_client.update_token_stats(chunk.usage)
+                if "usage" in chunk and chunk["usage"]:
+                    self.streaming_client.update_token_stats(chunk["usage"])
 
                 # Process choice (TS gets first choice directly)
-                if not hasattr(chunk, "choices") or not chunk.choices:
+                if "choices" not in chunk or not chunk["choices"]:
                     # Handle case where chunk doesn't have expected structure
-                    LogUtils.debug(f"Chunk missing choices: {getattr(chunk, '__dict__', chunk)}")
+                    LogUtils.debug(f"Chunk missing choices: {chunk}")
                     continue
 
-                choice = chunk.choices[0]
+                choice = chunk["choices"][0]
 
                 # Content (ignore reasoning_content unless model is reasoning-only)
-                if choice.delta:
-                    content = choice.delta.content
+                if "delta" in choice:
+                    content = choice["delta"].get("content")
                     if content:
                         full_response += content
                         colored_content = self.streaming_client.process_with_colorization(content)
                         print(colored_content, end="", flush=True)
 
                 # Tool calls
-                if choice.delta and choice.delta.tool_calls:
-                    for tool_call in choice.delta.tool_calls:
+                if "delta" in choice and choice["delta"].get("tool_calls"):
+                    for tool_call in choice["delta"]["tool_calls"]:
                         process_chunk_callback(tool_call, accumulated_tool_calls)
 
                 # Finish reason
-                if choice.finish_reason == "tool_calls":
+                if choice.get("finish_reason") == "tool_calls":
                     pass
 
         except Exception as e:
             LogUtils.error(f"\n[Streaming error: {e}]")
             return {

Index: poc/aicoder/v3/aicoder/core/streaming_client.py
==================================================================
--- poc/aicoder/v3/aicoder/core/streaming_client.py
+++ poc/aicoder/v3/aicoder/core/streaming_client.py
@@ -5,70 +5,45 @@
 from typing import List, Generator, Optional, Dict, Any
 
 from aicoder.core.config import Config
 from aicoder.core.markdown_colorizer import MarkdownColorizer
 from aicoder.utils.log import LogUtils
-from aicoder.type_defs.api_types import StreamChunk, ApiUsage
-from aicoder.type_defs.message_types import Message, MessageRole
-from aicoder.type_defs.tool_types import ToolDefinition
 from aicoder.utils.http_utils import fetch, Response
-from dataclasses import dataclass
-
-
-@dataclass
-class ChoiceDelta:
-    content: Optional[str] = None
-    reasoning_content: Optional[str] = None
-    tool_calls: Optional[List[Dict[str, Any]]] = None
-    role: Optional[str] = None
-
-
-@dataclass
-class Choice:
-    index: int
-    delta: Optional[ChoiceDelta] = None
-    finish_reason: Optional[str] = None
+
+
+
 
 
 class StreamingClient:
     """Handles streaming API requests - exact port from TypeScript"""
 
-    def __init__(self, stats: Optional[Any] = None, tool_manager: Optional[Any] = None, message_history: Optional[Any] = None):
+    def __init__(self, stats: Optional[Any] = None, tool_manager: Optional[Any] = None):
         self.stats = stats
         self.colorizer = MarkdownColorizer()
         self.tool_manager = tool_manager
-        self.message_history = message_history
-
-    def _wait_for_retry(self, attempt_num: int) -> None:
-        """Wait before next retry attempt with exponential backoff"""
-        delay = min(2**attempt_num, 64)  # Cap at 64 seconds max
-        time.sleep(delay)
 
     def stream_request(
         self,
-        messages: List[Message],
+        messages: List[Dict[str, Any]],
         stream: bool = True,
         throw_on_error: bool = False,
         send_tools: bool = True,
-    ) -> Generator[StreamChunk, None, None]:
-        """Stream API request"""
+    ) -> Generator[Dict[str, Any], None, None]:
+        """Stream API request - exact port from TypeScript streamRequest"""
         if Config.debug():
             LogUtils.debug(
                 f"*** stream_request called with {len(messages)} messages, send_tools={send_tools}"
             )
 
         start_time = time.time()
         if self.stats:
             self.stats.increment_api_requests()
 
-        # Reset recovery flag for each new request
-        self._recovery_attempted = False
+        # Retry up to 3 times like TS
+        max_retries = 3
 
-        max_retries = Config.effective_max_retries()
-        attempt_num = 1
-
-        while max_retries == 0 or attempt_num <= max_retries:
+        for attempt_num in range(1, max_retries + 1):
             config = {"base_url": Config.base_url(), "model": Config.model()}
 
             try:
                 self._log_retry_attempt(config, attempt_num)
                 request_data = self._prepare_request_data(
@@ -123,17 +98,10 @@
                 if not self._handle_attempt_error(
                     error, attempt_num, max_retries, throw_on_error, start_time
                 ):
                     return
 
-                # Wait before next retry (except for last attempt)
-                # In unlimited mode (max_retries=0), always wait and continue
-                if max_retries == 0 or attempt_num < max_retries:
-                    self._wait_for_retry(attempt_num)
-
-            attempt_num += 1
-
     def _log_retry_attempt(self, config: Dict[str, str], attempt_num: int) -> None:
         """Log retry attempt - exact port from TS"""
         if Config.debug() and attempt_num > 1:
             from aicoder.utils.log import LogUtils
 
@@ -189,23 +157,47 @@
                 )
             except:
                 LogUtils.debug("Error response body: <could not parse as JSON>")
 
     def _log_attempt_error(self, error: Exception, attempt_num: int) -> None:
-        """Log attempt error for debugging"""
-        # No-op - errors are now handled in _handle_attempt_error with user-visible messages
-        pass
+        """Log attempt error - exact port from TS"""
+        if Config.debug():
+            from aicoder.utils.log import LogUtils
+
+            LogUtils.error(f"Attempt {attempt_num} failed: {error}")
+            LogUtils.error(f"Error type: {type(error)}")
+            LogUtils.error(
+                f"Error stack: {getattr(error, '__traceback__', 'No stack')}"
+            )
+
+    def _handle_final_attempt_failure(
+        self, error: Exception, throw_on_error: bool, start_time: float
+    ) -> bool:
+        """Handle final attempt failure - exact port from TS"""
+        if self.stats:
+            self.stats.increment_api_errors()
+            self.stats.add_api_time((time.time() - start_time))
+
+        error_message = f"All API attempts failed. Last error: {str(error)}"
+        from aicoder.utils.log import LogUtils
+
+        LogUtils.error(error_message)
+
+        if throw_on_error:
+            raise Exception(error_message)
+
+        return False  # Exit retry loop
 
     def _update_stats_on_success(self, start_time: float) -> None:
         """Update stats on success - exact port from TS"""
         if self.stats:
             self.stats.increment_api_success()
             self.stats.add_api_time((time.time() - start_time))
 
     def _prepare_request_data(
         self,
-        messages: List[Message],
+        messages: List[Dict[str, Any]],
         model: Optional[str],
         stream: bool,
         send_tools: bool = True,
     ) -> Dict[str, Any]:
         """Prepare request data - exact port from TS"""
@@ -243,11 +235,11 @@
 
             if Config.debug():
                 LogUtils.debug(f"*** Tool definitions count: {len(tool_definitions)}")
                 LogUtils.debug(f"*** Message count: {len(data.get('messages', []))}")
 
-    def _format_messages(self, messages: List[Message]) -> List[Dict[str, Any]]:
+    def _format_messages(self, messages: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
         """Format messages for API - exact port from TS"""
         formatted = []
         for msg in messages:
             msg_dict = {"role": msg.get("role"), "content": msg.get("content")}
 
@@ -281,11 +273,11 @@
         """Check if response is streaming - exact port from TS"""
         return "text/event-stream" in content_type.lower()
 
     def _handle_streaming_response(
         self, response: Response
-    ) -> Generator[StreamChunk, None, None]:
+    ) -> Generator[Dict[str, Any], None, None]:
         """Handle streaming response - exact port from TS handleStreamingResponse"""
         try:
             if not response:
                 raise Exception("No response body for streaming")
 
@@ -331,41 +323,30 @@
                     try:
                         if Config.debug() and "tool_calls" in data_str:
                             LogUtils.debug(f"Tool call JSON: {data_str[:100]}...")
                         chunk_data = json.loads(data_str)
 
-                        # Convert dict choices to Choice objects
+                        # Use choice dicts directly
                         choices = []
                         if chunk_data.get("choices"):
                             for choice_dict in chunk_data["choices"]:
-                                # Convert delta dict to ChoiceDelta object
+                                # Use delta dict directly
                                 delta_dict = choice_dict.get("delta", {})
-                                delta = ChoiceDelta(
-                                    content=delta_dict.get("content"),
-                                    reasoning_content=delta_dict.get(
-                                        "reasoning_content"
-                                    ),
-                                    tool_calls=delta_dict.get("tool_calls"),
-                                    role=delta_dict.get("role"),
-                                )
-
-                                choice = Choice(
-                                    index=choice_dict.get("index", 0),
-                                    delta=delta,
-                                    finish_reason=choice_dict.get("finish_reason"),
-                                )
+                                delta = delta_dict
+
+                                choice = choice_dict
                                 choices.append(choice)
 
-                        # Create StreamChunk object
-                        chunk = StreamChunk(
-                            id=chunk_data.get("id"),
-                            object=chunk_data.get("object"),
-                            created=chunk_data.get("created"),
-                            model=chunk_data.get("model"),
-                            choices=choices,
-                            usage=self._create_usage(chunk_data.get("usage")),
-                        )
+                        # Create chunk dict
+                        chunk = {
+                            "id": chunk_data.get("id"),
+                            "object": chunk_data.get("object"),
+                            "created": chunk_data.get("created"),
+                            "model": chunk_data.get("model"),
+                            "choices": choices,
+                            "usage": self._create_usage(chunk_data.get("usage")),
+                        }
 
                         if (
                             Config.debug()
                             and chunk.choices
                             and chunk.choices[0].delta.tool_calls
@@ -383,21 +364,21 @@
             # Python doesn't have reader.releaseLock() like TS
             pass
 
     def _handle_non_streaming_response(
         self, response: Response
-    ) -> Generator[StreamChunk, None, None]:
+    ) -> Generator[Dict[str, Any], None, None]:
         """Handle non-streaming response - exact port from TS handleNonStreamingResponse"""
         data = response.json()
 
         # Convert non-streaming response to streaming format like TS
         if data.get("choices") and len(data["choices"]) > 0:
             choice = data["choices"][0]
 
             if choice.get("message"):
                 # Create synthetic streaming chunk from complete message
-                chunk: StreamChunk = {
+                chunk: Dict[str, Any] = {
                     "choices": [
                         {
                             "delta": {
                                 "content": choice["message"].get("content"),
                                 "tool_calls": choice["message"].get("tool_calls"),
@@ -409,11 +390,11 @@
                 }
 
                 # Update stats from usage if available
                 usage = data.get("usage")
                 if usage:
-                    self._update_stats_from_usage(ApiUsage(**usage))
+                    self._update_stats_from_usage(usage)
 
                 yield chunk
                 return
 
     def _handle_attempt_error(
@@ -422,51 +403,21 @@
         attempt_num: int,
         max_retries: int,
         throw_on_error: bool,
         start_time: float,
     ) -> bool:
-        """Handle attempt error"""
-        error_msg = str(error) if error else "Unknown error"
-
-        # Check if context is too large and attempt auto-recovery (once per request)
-        if self.message_history and self.stats and not throw_on_error:
-            current_size = self.stats.current_prompt_size or 0
-            threshold = Config.auto_compact_threshold()
-            if current_size > threshold and not hasattr(self, '_recovery_attempted'):
-                LogUtils.warn("[*] API failed with large context - attempting auto-recovery")
-                LogUtils.warn(f"[*] Context size: {current_size:,} (threshold: {threshold:,})")
-                self._recovery_attempted = True
-                self.message_history.force_compact_rounds(1)
-                LogUtils.info("[*] Retrying request after compaction...")
-                return True  # Retry with compacted context
-
-        # Display attempt count (unlimited mode doesn't show max)
-        if max_retries == 0:
-            LogUtils.warn(f"Attempt {attempt_num} failed: {error_msg}")
-            LogUtils.warn(f"Retrying in {min(2**attempt_num, 64)}s...")
-            return True  # Always retry in unlimited mode
-        else:
-            LogUtils.warn(f"Attempt {attempt_num}/{max_retries} failed: {error_msg}")
-
-            if attempt_num < max_retries:
-                LogUtils.warn(f"Retrying in {min(2**attempt_num, 64)}s...")
-                return True
-            else:
-                # Final attempt failed
-                if self.stats:
-                    self.stats.increment_api_errors()
-                    self.stats.add_api_time((time.time() - start_time))
-
-                LogUtils.error(f"All {max_retries} attempts failed. Last error: {error_msg}")
-                LogUtils.warn("Use /retry to try again or /retry limit <n> to increase retries.")
-
-                if throw_on_error:
-                    raise Exception(f"All attempts failed: {error_msg}")
-
-                return False
-
-    def _update_stats_from_usage(self, usage: ApiUsage) -> None:
+        """Handle attempt error - exact port from TS handleAttemptError"""
+        self._log_attempt_error(error, attempt_num)
+
+        if attempt_num < max_retries:
+            # Continue retrying
+            return True
+        else:
+            # Final attempt failed
+            return self._handle_final_attempt_failure(error, throw_on_error, start_time)
+
+    def _update_stats_from_usage(self, usage: Dict[str, Any]) -> None:
         """Update stats from usage - exact port from TS"""
         if self.stats:
             if hasattr(usage, "prompt_tokens"):
                 self.stats.add_prompt_tokens(usage.prompt_tokens)
             if hasattr(usage, "completion_tokens"):
@@ -479,22 +430,21 @@
 
     def reset_colorizer(self) -> None:
         """Reset colorizer state"""
         self.colorizer.reset_state()
 
-    def _create_usage(self, usage_data: Optional[Dict[str, Any]]) -> Optional[ApiUsage]:
+    def _create_usage(self, usage_data: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
         """Create ApiUsage object from dict data"""
         if not usage_data:
             return None
-        return ApiUsage(
-            prompt_tokens=usage_data.get("prompt_tokens"),
-            completion_tokens=usage_data.get("completion_tokens"),
-            total_tokens=usage_data.get("total_tokens"),
-        )
-
-    def update_token_stats(self, usage: Any) -> None:
+        return {
+            "prompt_tokens": usage_data.get("prompt_tokens"),
+            "completion_tokens": usage_data.get("completion_tokens"),
+            "total_tokens": usage_data.get("total_tokens"),
+        }
+    def update_token_stats(self, usage: Dict[str, Any]) -> None:
         """Update token statistics"""
         if self.stats and usage:
-            prompt_tokens = getattr(usage, "prompt_tokens", 0)
-            completion_tokens = getattr(usage, "completion_tokens", 0)
+            prompt_tokens = usage.get("prompt_tokens", 0)
+            completion_tokens = usage.get("completion_tokens", 0)
             self.stats.add_prompt_tokens(prompt_tokens)
             self.stats.add_completion_tokens(completion_tokens)

Index: poc/aicoder/v3/aicoder/core/tool_executor.py
==================================================================
--- poc/aicoder/v3/aicoder/core/tool_executor.py
+++ poc/aicoder/v3/aicoder/core/tool_executor.py
@@ -7,11 +7,10 @@
 from typing import Dict, Any, List, Union
 
 from aicoder.core.config import Config
 from aicoder.utils.log import LogUtils, LogOptions
 from aicoder.core.tool_formatter import ToolFormatter
-from aicoder.type_defs.tool_types import ToolExecutionArgs
 
 
 class ToolExecutor:
     """Handles tool execution, approval, and result display"""
 
@@ -30,20 +29,22 @@
 
     def execute_tool_calls(self, tool_calls: List[Dict[str, Any]]) -> None:
         """Execute multiple tool calls with approval and display"""
         if not tool_calls:
             return
-        
-        
 
         try:
             tool_results = []
 
             for tool_call in tool_calls:
                 result = self._execute_single_tool_call(tool_call)
                 if result:
                     tool_results.append(result)
+
+                # Stop if guidance mode was activated during tool approval
+                if self._guidance_mode:
+                    break
 
             # Add all tool results to message history
             self.message_history.add_tool_results(tool_results)
 
         except Exception as e:
@@ -132,22 +133,23 @@
 
         if not preview_result:
             return True
 
         # If can't approve (e.g., safety violation), show content directly without preview header
-        if not preview_result.can_approve:
-            LogUtils.print(preview_result.content)
+        if not preview_result.get("can_approve", False):
+            LogUtils.print(preview_result.get("content", ""))
             # Return the message for AI to see
             return {
                 "tool_call_id": tool_call_id,
-                "content": preview_result.content,
+                "content": preview_result.get("content", ""),
             }
 
         # Display preview content with header for normal previews
         # Only show file path in header if content doesn't already include it
         file_path = arguments.get('path')
-        if preview_result.content and "Path:" in preview_result.content:
+        preview_content = preview_result.get("content", "")
+        if preview_content and "Path:" in preview_content:
             # Content already includes path, don't duplicate in header
             formatted_preview = ToolFormatter.format_preview(preview_result, None)
         else:
             formatted_preview = ToolFormatter.format_preview(preview_result, file_path)
         LogUtils.print(formatted_preview)
@@ -210,37 +212,37 @@
             return False
 
     def _execute_tool(self, tool_name: str, arguments: Dict[str, Any], tool_call_id: str) -> Dict[str, Any]:
         """Execute the tool and return result"""
         try:
-            exec_args = ToolExecutionArgs(name=tool_name, arguments=arguments)
+            exec_args = {"name": tool_name, "arguments": arguments}
             result = self.tool_manager.execute_tool_with_args(exec_args)
 
             # Display result using tool's own formatting
             tool_def = self.tool_manager.tools.get(tool_name)
             self.display_tool_result(result, tool_def)
 
             # Return result for message history (AI always gets detailed version)
             return {
                 "tool_call_id": tool_call_id,
-                "content": result.detailed,  # AI always receives detailed version
+                "content": result["detailed"],  # AI always receives detailed version
             }
         except Exception as e:
             LogUtils.error(f"✗ Error executing {tool_name}: {str(e)}")
             return {
                 "tool_call_id": tool_call_id,
                 "content": f"Error: {str(e)}",
             }
 
     def display_tool_result(self, result, tool_def: Dict[str, Any]) -> None:
-        """Display tool execution result using the new ToolResult format"""
+        """Display tool execution result using dict format"""
         if tool_def and tool_def.get("hide_results"):
             LogUtils.success("[*] Done")
         else:
             # Display based on detail mode
             if Config.detail_mode():
                 # Detail mode: show detailed first, then friendly
-                LogUtils.print(result.detailed)
-                LogUtils.print(result.friendly)
+                LogUtils.print(result["detailed"])
+                LogUtils.print(result["friendly"])
             else:
                 # Non-detail mode: show only friendly
-                LogUtils.print(result.friendly)
+                LogUtils.print(result["friendly"])

Index: poc/aicoder/v3/aicoder/core/tool_formatter.py
==================================================================
--- poc/aicoder/v3/aicoder/core/tool_formatter.py
+++ poc/aicoder/v3/aicoder/core/tool_formatter.py
@@ -6,11 +6,10 @@
 import json
 from typing import Dict, Any, Optional, Union
 from dataclasses import dataclass
 
 from aicoder.core.config import Config
-from aicoder.type_defs.tool_types import ToolPreview, ToolResult
 
 
 class ToolFormatter:
     """Tool formatter following TypeScript patterns exactly"""
 
@@ -41,39 +40,39 @@
                 colored_lines.append(line)
 
         return "\n".join(colored_lines)
 
     @staticmethod
-    def format_for_ai(result: ToolResult) -> str:
+    def format_for_ai(result: Dict[str, Any]) -> str:
         """Format tool result for AI consumption - always returns detailed version"""
-        return result.detailed
+        return result["detailed"]
 
     @staticmethod
-    def format_for_display(result: ToolResult) -> Optional[str]:
+    def format_for_display(result: Dict[str, Any]) -> Optional[str]:
         """Format tool result for local display - always show friendly when available"""
-        return result.friendly
+        return result["friendly"]
 
     @staticmethod
     def format_preview(preview, file_path=None) -> str:
         """Format preview for approval - simplified design"""
         from aicoder.utils.log import LogUtils, LogOptions
 
         lines = []
-        
+
         # Show file path if available
         if file_path:
             preview_title = file_path
         else:
             preview_title = "Preview"
-            
+
         lines.append(
             f"{Config.colors['cyan']}[PREVIEW] {preview_title}{Config.colors['reset']}"
         )
         lines.append("")
-        
+
         # Always show content - tools are responsible for formatting
-        lines.append(preview.content)
+        lines.append(preview.get("content", ""))
 
         return "\n".join(lines)
 
     @staticmethod
     def _format_label(key: str) -> str:

Index: poc/aicoder/v3/aicoder/core/tool_manager.py
==================================================================
--- poc/aicoder/v3/aicoder/core/tool_manager.py
+++ poc/aicoder/v3/aicoder/core/tool_manager.py
@@ -3,33 +3,29 @@
 Following TypeScript structure exactly
 """
 
 import json
 from typing import Dict, Any, Optional, List, Set
-from dataclasses import dataclass
 
 from aicoder.core.stats import Stats
 from aicoder.core.tool_formatter import ToolFormatter
-from aicoder.type_defs.tool_types import ToolResult
 from aicoder.tools.internal.read_file import TOOL_DEFINITION as READ_FILE_DEF
 from aicoder.tools.internal.write_file import TOOL_DEFINITION as WRITE_FILE_DEF
 from aicoder.tools.internal.edit_file import TOOL_DEFINITION as EDIT_FILE_DEF
 from aicoder.tools.internal.run_shell_command import (
     TOOL_DEFINITION as RUN_SHELL_COMMAND_DEF,
 )
 from aicoder.tools.internal.grep import TOOL_DEFINITION as GREP_DEF
 from aicoder.tools.internal.list_directory import TOOL_DEFINITION as LIST_DIRECTORY_DEF
-from aicoder.type_defs.api_types import ToolCall
-from aicoder.type_defs.tool_types import ToolExecutionArgs, ToolDefinition, ToolResult
 
 
 class ToolManager:
     """Tool manager following TypeScript patterns exactly"""
 
     def __init__(self, stats: Stats):
         self.stats = stats
-        self.tools: Dict[str, ToolDefinition] = {}
+        self.tools: Dict[str, Dict[str, Any]] = {}
         self.read_files: Set[str] = set()
 
         # Register internal tools
         self._register_internal_tools()
 
@@ -58,15 +54,15 @@
             definitions.append(definition)
 
         return definitions
 
     def execute_tool_call(
-        self, tool_call: ToolCall, skip_preview: bool = False
-    ) -> ToolResult:
+        self, tool_call: Dict[str, Any], skip_preview: bool = False
+    ) -> Dict[str, Any]:
         """Execute a tool call (internal tools only)"""
-        tool_id = tool_call.id
-        func = tool_call.function
+        tool_id = tool_call.get("id")
+        func = tool_call.get("function", {})
         name = func.get("name")
         args = func.get("arguments", "{}")
 
         try:
             tool_def = self._validate_tool(name)
@@ -79,18 +75,18 @@
             tool_output = self._execute_tool(name, args_obj, tool_def)
 
             return self._format_result(tool_output, tool_def, name, tool_id)
 
         except Exception as error:
-            return ToolResult(
-                tool=name,
-                friendly=f"✗ Error executing {name}: {str(error)}",
-                detailed=f"Tool execution failed: {str(error)}",
-                success=False,
-            )
-
-    def _validate_tool(self, name: Optional[str]) -> ToolDefinition:
+            return {
+                "tool": name,
+                "friendly": f"✗ Error executing {name}: {str(error)}",
+                "detailed": f"Tool execution failed: {str(error)}",
+                "success": False,
+            }
+
+    def _validate_tool(self, name: Optional[str]) -> Dict[str, Any]:
         """Validate tool exists"""
         if not name:
             raise Exception("Tool name is required")
 
         tool_def = self.tools.get(name)
@@ -110,12 +106,12 @@
         """Validate required arguments for each tool"""
         # Validation handled by individual tools in execute
         pass
 
     def _execute_tool(
-        self, name: str, args_obj: Dict[str, Any], tool_def: ToolDefinition
-    ) -> ToolResult:
+        self, name: str, args_obj: Dict[str, Any], tool_def: Dict[str, Any]
+    ) -> Dict[str, Any]:
         """Execute the tool"""
         try:
             execute_func = tool_def.get("execute")
             if not execute_func:
                 raise Exception(f"Tool {name} has no execute method")
@@ -131,32 +127,32 @@
         except Exception as exec_error:
             raise Exception(f"Tool execution failed for {name}: {str(exec_error)}")
 
     def _format_result(
         self,
-        tool_output: ToolResult,
-        tool_def: ToolDefinition,
+        tool_output: Dict[str, Any],
+        tool_def: Dict[str, Any],
         tool_name: str,
         tool_call_id: str,
-    ) -> ToolResult:
+    ) -> Dict[str, Any]:
         """Format result for AI and display"""
         # Format for AI and display
         ai_result = ToolFormatter.format_for_ai(tool_output)
         friendly_result = ToolFormatter.format_for_display(tool_output)
 
         # Check if result is too large
         ai_result = self._check_size(ai_result, tool_def, tool_name)
 
-        return ToolResult(
-            tool=tool_name,
-            friendly=friendly_result,
-            detailed=ai_result,
-            success=True,
-        )
+        return {
+            "tool": tool_name,
+            "friendly": friendly_result,
+            "detailed": ai_result,
+            "success": True,
+        }
 
     def _check_size(
-        self, content: str, tool_def: ToolDefinition, tool_name: str
+        self, content: str, tool_def: Dict[str, Any], tool_name: str
     ) -> str:
         """Check if content is too large and truncate if needed"""
         max_size = 10000  # Default max size
         max_len = max_size - 200  # Leave room for error message
 
@@ -171,19 +167,19 @@
         tool_def = self.tools.get(tool_name)
         if not tool_def:
             return True
         return not tool_def.get("auto_approved", False)
 
-    def execute_tool_with_args(self, execution_args: "ToolExecutionArgs") -> ToolResult:
+    def execute_tool_with_args(self, execution_args: Dict[str, Any]) -> Dict[str, Any]:
         """Execute tool with ToolExecutionArgs (compatibility method)"""
-        # Create ToolCall from ToolExecutionArgs
-        tool_call = ToolCall(
-            id=f"tool_{execution_args.name}_{hash(str(execution_args.arguments))}",
-            type="function",
-            function={
-                "name": execution_args.name,
-                "arguments": json.dumps(execution_args.arguments),
+        # Create ToolCall dict from execution args
+        tool_call = {
+            "id": f"tool_{execution_args["name"]}_{hash(str(execution_args["arguments"]))}",
+            "type": "function",
+            "function": {
+                "name": execution_args["name"],
+                "arguments": json.dumps(execution_args["arguments"]),
             },
-        )
+        }
 
         # Execute using existing method
         return self.execute_tool_call(tool_call)

Index: poc/aicoder/v3/aicoder/tools/internal/edit_file.py
==================================================================
--- poc/aicoder/v3/aicoder/tools/internal/edit_file.py
+++ poc/aicoder/v3/aicoder/tools/internal/edit_file.py
@@ -4,11 +4,10 @@
 """
 
 import os
 import tempfile
 from typing import Dict, Any, List, Tuple
-from aicoder.type_defs.tool_types import ToolResult, ToolPreview
 from aicoder.core.config import Config
 from aicoder.core.file_access_tracker import FileAccessTracker
 from aicoder.utils.file_utils import file_exists, read_file, write_file
 from aicoder.utils.diff_utils import generate_unified_diff_with_status
 
@@ -49,11 +48,11 @@
         start = pos + 1
 
     return occurrences
 
 
-def execute(args: Dict[str, Any]) -> ToolResult:
+def execute(args: Dict[str, Any]) -> Dict[str, Any]:
     """Edit file by replacing text"""
     path = args.get("path")
     old_string = args.get("old_string")
     new_string = args.get("new_string")
 
@@ -68,27 +67,27 @@
     if not file_exists(path):
         raise Exception(f"File not found: {path}")
 
     # Safety check: File must have been read first (tracked by FileAccessTracker)
     if not FileAccessTracker.was_file_read(path):
-        return ToolResult(
-            tool="edit_file",
-            friendly=f"WARNING: Must read file '{path}' first before editing",
-            detailed=f"Must read file first. Use read_file('{path}') before editing."
-        )
+        return {
+            "tool": "edit_file",
+            "friendly": f"WARNING: Must read file '{path}' first before editing",
+            "detailed": f"Must read file first. Use read_file('{path}') before editing."
+        }
 
     try:
         content = read_file(path)
 
         if old_string not in content:
             from aicoder.utils.file_utils import get_relative_path
             relative_path = get_relative_path(path)
-            return ToolResult(
-                tool="edit_file",
-                friendly=f"ERROR: Text not found in '{relative_path}' - check exact match including whitespace",
-                detailed=f"old_string not found in file. Use read_file('{relative_path}') to see current content and ensure exact match."
-            )
+            return {
+                "tool": "edit_file",
+                "friendly": f"ERROR: Text not found in '{relative_path}' - check exact match including whitespace",
+                "detailed": f"old_string not found in file. Use read_file('{relative_path}') to see current content and ensure exact match."
+            }
 
         # Create temp files for diff preview
         temp_old = tempfile.NamedTemporaryFile(
             mode="w", suffix="_old.txt", delete=False
         )
@@ -134,22 +133,22 @@
         else:
             friendly = (
                 f"✓ Updated '{path}' ({len(old_string)} → {len(new_string)} chars)"
             )
 
-        return ToolResult(
-            tool="edit_file",
-            friendly=friendly,
-            detailed=f"Edit completed: {friendly}"
-        )
+        return {
+            "tool": "edit_file",
+            "friendly": friendly,
+            "detailed": f"Edit completed: {friendly}"
+        }
 
     except Exception as e:
-        return ToolResult(
-            tool="edit_file",
-            friendly=f"❌ Error editing {path}: {str(e)}",
-            detailed=f"Error editing file '{path}': {str(e)}"
-        )
+        return {
+            "tool": "edit_file",
+            "friendly": f"❌ Error editing {path}: {str(e)}",
+            "detailed": f"Error editing file '{path}': {str(e)}"
+        }
 
 
 def generate_preview(args):
     """Generate preview for approval"""
     path = args.get("path")
@@ -160,47 +159,47 @@
         msg = []
         if not path:
             msg.append("- path is required")
         if old_string is None:
             msg.append("- old_string is required")
-        return ToolPreview(
-            tool="edit_file",
-            content=f"Error: Missing required arguments:\n" + "\n".join(msg),
-            can_approve=False,
-        )
+        return {
+            "tool": "edit_file",
+            "content": f"Error: Missing required arguments:\n" + "\n".join(msg),
+            "can_approve": False,
+        }
 
     try:
         from aicoder.utils.file_utils import get_relative_path
         relative_path = get_relative_path(path)
         
         if not _check_sandbox(path, print_message=False):
             # Don't print in check since preview will show message
             resolved_path = os.path.abspath(path)
             current_dir = os.getcwd()
-            return ToolPreview(
-                tool="edit_file",
-                content=f'Path: {path}\n[x] Sandbox: trying to access "{resolved_path}" outside current directory "{current_dir}"',
-                can_approve=False,
-            )
+            return {
+                "tool": "edit_file",
+                "content": f'Path: {path}\n[x] Sandbox: trying to access "{resolved_path}" outside current directory "{current_dir}"',
+                "can_approve": False,
+            }
 
         if not file_exists(path):
-            return ToolPreview(
-                tool="edit_file",
-                content=f"Path: {relative_path}\nError: File not found",
-                can_approve=False,
-            )
+            return {
+                "tool": "edit_file",
+                "content": f"Path: {relative_path}\nError: File not found",
+                "can_approve": False,
+            }
 
         content = read_file(path)
 
         if old_string not in content:
             from aicoder.utils.file_utils import get_relative_path
             relative_path = get_relative_path(path)
-            return ToolPreview(
-                tool="edit_file",
-                content=f"Path: {relative_path}\nError: old_string not found in file. Use read_file('{relative_path}') to see current content and ensure exact match.",
-                can_approve=False,
-            )
+            return {
+                "tool": "edit_file",
+                "content": f"Path: {relative_path}\nError: old_string not found in file. Use read_file('{relative_path}') to see current content and ensure exact match.",
+                "can_approve": False,
+            }
 
         # Safety check for file reads
         can_approve = True
         warning = None
         safety_violation_content = None
@@ -245,15 +244,15 @@
                 preview_content = f"Path: {relative_path}\n\n{colorized_diff}"
             else:
                 # Safety violation: already contains path and warning
                 preview_content = safety_violation_content
 
-            return ToolPreview(
-                tool="edit_file",
-                content=preview_content,
-                can_approve=can_approve,
-            )
+            return {
+                "tool": "edit_file",
+                "content": preview_content,
+                "can_approve": can_approve,
+            }
 
         finally:
             # Cleanup temp files
             try:
                 os.unlink(temp_old.name)
@@ -263,15 +262,15 @@
 
     except Exception as e:
         from aicoder.utils.file_utils import get_relative_path
         path = args.get('path', 'unknown')
         relative_path = get_relative_path(path) if path != 'unknown' else 'unknown'
-        return ToolPreview(
-            tool="edit_file",
-            content=f"Path: {relative_path}\nError: {str(e)}",
-            can_approve=False,
-        )
+        return {
+            "tool": "edit_file",
+            "content": f"Path: {relative_path}\nError: {str(e)}",
+            "can_approve": False,
+        }
 
 
 def format_arguments(args):
     """Format arguments for display"""
     path = args.get("path")

Index: poc/aicoder/v3/aicoder/tools/internal/grep.py
==================================================================
--- poc/aicoder/v3/aicoder/tools/internal/grep.py
+++ poc/aicoder/v3/aicoder/tools/internal/grep.py
@@ -4,11 +4,10 @@
 """
 
 import os
 import subprocess
 from typing import Dict, Any, Optional
-from aicoder.type_defs.tool_types import ToolResult
 from aicoder.core.config import Config
 
 
 def validateArguments(args: Dict[str, Any]) -> None:
     """Validate grep arguments"""
@@ -33,11 +32,11 @@
         parts.append(f"Context: {context} lines")
 
     return "\n  ".join(parts)
 
 
-def execute(args: Dict[str, Any]) -> ToolResult:
+def execute(args: Dict[str, Any]) -> Dict[str, Any]:
     """Search for text in files using ripgrep or grep"""
     text = args.get("text")
     path = args.get("path", ".")
     max_results = args.get("max_results", 2000)
     context = args.get("context", 2)
@@ -52,23 +51,23 @@
             # Create sandbox message in result instead of printing
             import os
             resolved_path = os.path.abspath(path)
             current_dir = os.getcwd()
             sandbox_msg = f'Path: {path}\n[x] Sandbox: trying to access "{resolved_path}" outside current directory "{current_dir}"'
-            return ToolResult(
-                tool="grep",
-                friendly=sandbox_msg,
-                detailed=sandbox_msg
-            )
+            return {
+                "tool": "grep",
+                "friendly": sandbox_msg,
+                "detailed": sandbox_msg
+            }
 
         # Validate search text
         if not text.strip():
-            return ToolResult(
-                tool="grep",
-                friendly=f'ERROR: Search text cannot be empty.',
-                detailed=f'Search text "{text}" is invalid - it cannot be empty or whitespace only.'
-            )
+            return {
+                "tool": "grep",
+                "friendly": f'ERROR: Search text cannot be empty.',
+                "detailed": f'Search text "{text}" is invalid - it cannot be empty or whitespace only.'
+            }
 
         # Build command using ripgrep (matching TypeScript exactly)
         import os
 
         search_path = os.path.abspath(path)
@@ -93,28 +92,28 @@
         if not matches:
             friendly = f"🔍 No matches found for '{text}'"
         else:
             friendly = f"🔍 Found {len(matches)} matches for '{text}'"
 
-        return ToolResult(
-            tool="grep",
-            friendly=friendly,
-            detailed=f"Search completed: {friendly}\n\nCommand: {' '.join(cmd)}\n\nMatches:\n{chr(10).join(matches)}"
-        )
+        return {
+            "tool": "grep",
+            "friendly": friendly,
+            "detailed": f"Search completed: {friendly}\n\nCommand: {' '.join(cmd)}\n\nMatches:\n{chr(10).join(matches)}"
+        }
 
     except subprocess.TimeoutExpired:
-        return ToolResult(
-            tool="grep",
-            friendly=f"⏰ Search timed out",
-            detailed=f"Search for '{text}' timed out. Command: {' '.join(cmd)}"
-        )
+        return {
+            "tool": "grep",
+            "friendly": f"⏰ Search timed out",
+            "detailed": f"Search for '{text}' timed out. Command: {' '.join(cmd)}"
+        }
     except Exception as e:
-        return ToolResult(
-            tool="grep",
-            friendly=f"❌ Search error: {str(e)}",
-            detailed=f"Search for '{text}' failed with error: {str(e)}"
-        )
+        return {
+            "tool": "grep",
+            "friendly": f"❌ Search error: {str(e)}",
+            "detailed": f"Search for '{text}' failed with error: {str(e)}"
+        }
 
 
 def _has_ripgrep() -> bool:
     """Check if ripgrep is available"""
     try:

Index: poc/aicoder/v3/aicoder/tools/internal/list_directory.py
==================================================================
--- poc/aicoder/v3/aicoder/tools/internal/list_directory.py
+++ poc/aicoder/v3/aicoder/tools/internal/list_directory.py
@@ -3,11 +3,10 @@
 Following TypeScript structure exactly
 """
 
 import os
 from typing import Dict, Any, Optional
-from aicoder.type_defs.tool_types import ToolResult
 from aicoder.core.config import Config
 
 
 def validateArguments(args: Dict[str, Any]) -> None:
     """Validate list directory arguments"""
@@ -22,11 +21,11 @@
     if path and path != ".":
         return f"Listing directory: {path}"
     return ""
 
 
-def execute(args: Dict[str, Any]) -> ToolResult:
+def execute(args: Dict[str, Any]) -> Dict[str, Any]:
     """List directory contents"""
     path = args.get("path", ".")
     MAX_FILES = 100
 
     try:
@@ -38,23 +37,23 @@
         # Check sandbox restrictions
         # Check sandbox restrictions, but don't print message (will show in result)
         if not _check_sandbox(resolved_path, print_message=False):
             # Create sandbox message in result instead of printing
             sandbox_msg = f'Path: {path}\n[x] Sandbox: trying to access "{resolved_path}" outside current directory "{os.getcwd()}"'
-            return ToolResult(
-                tool="list_directory",
-                friendly=sandbox_msg,
-                detailed=sandbox_msg
-            )
+            return {
+                "tool": "list_directory",
+                "friendly": sandbox_msg,
+                "detailed": sandbox_msg
+            }
 
         # Check if path exists and is a directory
         if not os.path.exists(resolved_path) or not os.path.isdir(resolved_path):
-            return ToolResult(
-                tool="list_directory",
-                friendly=f"Directory not found: '{resolved_path}'",
-                detailed=f"Directory not found at '{resolved_path}'. Path does not exist or is not a directory."
-            )
+            return {
+                "tool": "list_directory",
+                "friendly": f"Directory not found: '{resolved_path}'",
+                "detailed": f"Directory not found at '{resolved_path}'. Path does not exist or is not a directory."
+            }
 
         # Use find to list files - much faster and simpler (matching TypeScript)
         import subprocess
 
         find_command = f'find "{resolved_path}" -type f -print0 | head -z -n {MAX_FILES + 1} | tr "\\0" "\\n"'
@@ -75,34 +74,34 @@
         actual_count = len(files)
         limited_files = files[:MAX_FILES]
 
         # Create output matching TypeScript structure
         if limited_files == []:
-            return ToolResult(
-                tool="list_directory",
-                friendly=f"Directory is empty: '{resolved_path}'",
-                detailed=f"Directory '{resolved_path}' exists but contains no files or subdirectories."
-            )
+            return {
+                "tool": "list_directory",
+                "friendly": f"Directory is empty: '{resolved_path}'",
+                "detailed": f"Directory '{resolved_path}' exists but contains no files or subdirectories."
+            }
         elif actual_count > MAX_FILES:
-            return ToolResult(
-                tool="list_directory",
-                friendly=f"Found {actual_count}+ files (limited to {MAX_FILES}) in '{resolved_path}'",
-                detailed=f"Directory contains {actual_count} items total. Showing first {MAX_FILES}:\n\n{chr(10).join(limited_files)}"
-            )
+            return {
+                "tool": "list_directory",
+                "friendly": f"Found {actual_count}+ files (limited to {MAX_FILES}) in '{resolved_path}'",
+                "detailed": f"Directory contains {actual_count} items total. Showing first {MAX_FILES}:\n\n{chr(10).join(limited_files)}"
+            }
         else:
-            return ToolResult(
-                tool="list_directory",
-                friendly=f"✓ Found {actual_count} files in '{resolved_path}'",
-                detailed=f"Directory '{resolved_path}' contents ({actual_count} items):\n\n{chr(10).join(limited_files)}"
-            )
+            return {
+                "tool": "list_directory",
+                "friendly": f"✓ Found {actual_count} files in '{resolved_path}'",
+                "detailed": f"Directory '{resolved_path}' contents ({actual_count} items):\n\n{chr(10).join(limited_files)}"
+            }
 
     except Exception as e:
-        return ToolResult(
-            tool="list_directory",
-            friendly=f"❌ Error listing directory: {str(e)}",
-            detailed=f"Error listing directory '{path}': {str(e)}"
-        )
+        return {
+            "tool": "list_directory",
+            "friendly": f"❌ Error listing directory: {str(e)}",
+            "detailed": f"Error listing directory '{path}': {str(e)}"
+        }
 
 
 def _list_single(path: str, show_hidden: bool) -> list:
     """List single directory"""
     try:

Index: poc/aicoder/v3/aicoder/tools/internal/read_file.py
==================================================================
--- poc/aicoder/v3/aicoder/tools/internal/read_file.py
+++ poc/aicoder/v3/aicoder/tools/internal/read_file.py
@@ -3,11 +3,10 @@
 Following TypeScript structure exactly
 """
 
 import os
 from typing import Dict, Any
-from aicoder.type_defs.tool_types import ToolResult, ToolPreview
 from aicoder.core.config import Config
 from aicoder.core.file_access_tracker import FileAccessTracker
 from aicoder.utils.file_utils import file_exists, read_file as file_read
 
 DEFAULT_READ_LIMIT = 2000
@@ -33,11 +32,11 @@
         return False
     
     return True
 
 
-def execute(args: Dict[str, Any]) -> ToolResult:
+def execute(args: Dict[str, Any]) -> Dict[str, Any]:
     """Read file with pagination"""
     path = args.get("path")
     offset = args.get("offset", 0)
     limit = args.get("limit", DEFAULT_READ_LIMIT)
 
@@ -60,15 +59,15 @@
         
         lines = content.split("\n")
 
         # Apply offset and limit
         if offset >= len(lines):
-            return ToolResult(
-                tool="read_file",
-                friendly=f"File {path} has {len(lines)} lines, but offset {offset} is beyond end of file",
-                detailed=f"Cannot read file '{path}'. Requested offset {offset} but file only has {len(lines)} lines."
-            )
+            return {
+                "tool": "read_file",
+                "friendly": f"File {path} has {len(lines)} lines, but offset {offset} is beyond end of file",
+                "detailed": f"Cannot read file '{path}'. Requested offset {offset} but file only has {len(lines)} lines."
+            }
 
         end_index = min(offset + limit, len(lines))
         selected_lines = lines[offset:end_index]
         selected_content = "\n".join(selected_lines)
 
@@ -93,41 +92,40 @@
 
         friendly_msg = f"Read {len(selected_lines)} lines from {path}"
         if offset > 0 or end_index < len(lines):
             friendly_msg += f" (showing lines {offset + 1}-{end_index} of {len(lines)})"
 
-        return ToolResult(
-            tool="read_file",
-            friendly=friendly_msg,
-            detailed=f"File: {path}\nTotal lines: {len(lines)}\nShowing: lines {offset + 1}-{end_index}\n\nContent:\n{selected_content}"
-        )
+        return {
+            "tool": "read_file",
+            "friendly": friendly_msg,
+            "detailed": f"File: {path}\nTotal lines: {len(lines)}\nShowing: lines {offset + 1}-{end_index}\n\nContent:\n{selected_content}"
+        }
 
     except Exception as e:
-        return ToolResult(
-            tool="read_file",
-            friendly=f"❌ Error reading {path}: {str(e)}",
-            detailed=f"Error reading file '{path}': {str(e)}"
-        )
+        return {
+            "tool": "read_file",
+            "friendly": f"❌ Error reading {path}: {str(e)}",
+            "detailed": f"Error reading file '{path}': {str(e)}"
+        }
 
 
 def generatePreview(args):
     """Generate preview with sandbox validation (executed BEFORE approval)"""
     path = args.get("path", "")
 
     # Check sandbox first - don't print message since preview will show it
     if not _check_sandbox(path, print_message=False):
-        from aicoder.core.tool_formatter import ToolPreview
         import os.path
-        
+
         resolved_path = os.path.abspath(path)
         current_dir = os.getcwd()
-        
-        return ToolPreview(
-            tool="read_file",
-            content=f'Path: {path}\n[x] Sandbox: trying to access "{resolved_path}" outside current directory "{current_dir}"',
-            can_approve=False,
-        )
+
+        return {
+            "tool": "read_file",
+            "content": f'Path: {path}\n[x] Sandbox: trying to access "{resolved_path}" outside current directory "{current_dir}"',
+            "can_approve": False,
+        }
 
     # If sandbox passes, no preview needed
     return None
 
 

Index: poc/aicoder/v3/aicoder/tools/internal/run_shell_command.py
==================================================================
--- poc/aicoder/v3/aicoder/tools/internal/run_shell_command.py
+++ poc/aicoder/v3/aicoder/tools/internal/run_shell_command.py
@@ -3,15 +3,14 @@
 Following TypeScript structure exactly
 """
 
 import subprocess
 from typing import Dict, Any, Optional
-from aicoder.type_defs.tool_types import ToolResult
 from aicoder.core.config import Config
 
 
-def execute(args: Dict[str, Any]) -> ToolResult:
+def execute(args: Dict[str, Any]) -> Dict[str, Any]:
     """Execute shell command with timeout"""
     command = args.get("command")
     timeout = args.get("timeout", 30)
     cwd = args.get("cwd")
 
@@ -45,28 +44,28 @@
             if output:
                 output += "\nSTDERR:\n" + result.stderr
             else:
                 output = result.stderr
 
-        return ToolResult(
-            tool="run_shell_command",
-            friendly=friendly,
-            detailed=f"Command: {command}\nExit code: {result.returncode}\nTimeout: {timeout}s\nWorking directory: {cwd or '.'}\n\nOutput:\n{output}"
-        )
+        return {
+            "tool": "run_shell_command",
+            "friendly": friendly,
+            "detailed": f"Command: {command}\nExit code: {result.returncode}\nTimeout: {timeout}s\nWorking directory: {cwd or '.'}\n\nOutput:\n{output}"
+        }
 
     except subprocess.TimeoutExpired:
-        return ToolResult(
-            tool="run_shell_command",
-            friendly=f"✗ Command timed out after {timeout}s (exit code: 124)",
-            detailed=f"Command timed out after {timeout}s: {command}"
-        )
+        return {
+            "tool": "run_shell_command",
+            "friendly": f"✗ Command timed out after {timeout}s (exit code: 124)",
+            "detailed": f"Command timed out after {timeout}s: {command}"
+        }
     except Exception as e:
-        return ToolResult(
-            tool="run_shell_command",
-            friendly=f"✗ Command failed: {str(e)}",
-            detailed=f"Command failed: {command}\nError: {str(e)}"
-        )
+        return {
+            "tool": "run_shell_command",
+            "friendly": f"✗ Command failed: {str(e)}",
+            "detailed": f"Command failed: {command}\nError: {str(e)}"
+        }
 
 
 # Tool definition matching TypeScript structure
 TOOL_DEFINITION = {
     "type": "internal",

Index: poc/aicoder/v3/aicoder/tools/internal/write_file.py
==================================================================
--- poc/aicoder/v3/aicoder/tools/internal/write_file.py
+++ poc/aicoder/v3/aicoder/tools/internal/write_file.py
@@ -5,11 +5,10 @@
 
 import os
 import sys
 import tempfile
 from typing import Dict, Any
-from aicoder.type_defs.tool_types import ToolResult, ToolPreview, ToolResult
 from aicoder.core.config import Config
 from aicoder.core.file_access_tracker import FileAccessTracker
 from aicoder.utils.file_utils import file_exists, write_file as file_write, get_relative_path
 from aicoder.utils.diff_utils import generate_unified_diff_with_status, colorize_diff
 
@@ -33,11 +32,11 @@
         return False
     
     return True
 
 
-def execute(args: Dict[str, Any]) -> ToolResult:
+def execute(args: Dict[str, Any]) -> Dict[str, Any]:
     """Write content to file"""
     path = args.get("path")
     content = args.get("content", "")
 
     if not path:
@@ -110,15 +109,15 @@
                 f"Lines: {len(content.splitlines()) if content else 0}"
             ]
             
             detailed = "\n".join(detailed_parts)
 
-            return ToolResult(
-                tool="write_file",
-                friendly=friendly,
-                detailed=detailed
-            )
+            return {
+                "tool": "write_file",
+                "friendly": friendly,
+                "detailed": detailed
+            }
 
         finally:
             # Cleanup temp files
             try:
                 os.unlink(temp_old.name)
@@ -125,18 +124,18 @@
                 os.unlink(temp_new.name)
             except:
                 pass
 
     except Exception as e:
-        return ToolResult(
-            tool="write_file",
-            friendly=f"❌ Error writing {get_relative_path(path)}: {str(e)}",
-            detailed=(
+        return {
+            "tool": "write_file",
+            "friendly": f"❌ Error writing {get_relative_path(path)}: {str(e)}",
+            "detailed": (
                 f"Path: {path}\n"
                 f"Error: {str(e)}"
             )
-        )
+        }
 
 
 def generate_preview(args):
     """Generate preview for approval"""
     path = args.get("path")
@@ -153,15 +152,15 @@
             safety_message = (
                 f"Path: {relative_path}\n"
                 "[!] Warning: The file must be read before editing."
             )
             
-            return ToolPreview(
-                tool="write_file",
-                content=safety_message,
-                can_approve=False
-            )
+            return {
+                "tool": "write_file",
+                "content": safety_message,
+                "can_approve": False
+            }
 
         # Create temporary files for diff
         temp_old = tempfile.NamedTemporaryFile(
             mode="w", suffix="_old.txt", delete=False
         )
@@ -200,16 +199,16 @@
             else:
                 preview_content = (
                     f"New file will be created:\n\n"
                     f"{colorized_diff}"
                 )
-                
-            return ToolPreview(
-                tool="write_file",
-                content=preview_content,
-                can_approve=True
-            )
+
+            return {
+                "tool": "write_file",
+                "content": preview_content,
+                "can_approve": True
+            }
 
         finally:
             # Cleanup temp files
             try:
                 os.unlink(temp_old.name)
@@ -216,15 +215,15 @@
                 os.unlink(temp_new.name)
             except:
                 pass
 
     except Exception as e:
-        return ToolPreview(
-            tool="write_file",
-            content=f"Error: {str(e)}",
-            can_approve=False
-        )
+        return {
+            "tool": "write_file",
+            "content": f"Error: {str(e)}",
+            "can_approve": False
+        }
 
 
 def format_arguments(args):
     """Format arguments for display"""
     path = args.get("path", "")

DELETED poc/aicoder/v3/aicoder/type_defs/__init__.py
DELETED poc/aicoder/v3/aicoder/type_defs/api_types.py
DELETED poc/aicoder/v3/aicoder/type_defs/message_types.py
DELETED poc/aicoder/v3/aicoder/type_defs/system_types.py
DELETED poc/aicoder/v3/aicoder/type_defs/tool_types.py
DELETED poc/aicoder/v3/test_api_call.py
DELETED poc/aicoder/v3/test_compaction_simple.py
ADDED   poc/aicoder/v3/tests/fix_verification.py
ADDED   poc/aicoder/v3/tests/safety/type_removal_test.py
Index: poc/aicoder/v3/tests/test_aicoder.py
==================================================================
--- poc/aicoder/v3/tests/test_aicoder.py
+++ poc/aicoder/v3/tests/test_aicoder.py
@@ -9,11 +9,14 @@
 from aicoder.core.message_history import MessageHistory
 from aicoder.core.streaming_client import StreamingClient
 from aicoder.core.tool_manager import ToolManager
 from aicoder.core.stats import Stats
 from aicoder.core.command_handler import CommandHandler
-from aicoder.type_defs.message_types import Message, MessageRole
+
+# Type definitions are now dicts
+Message = dict[str, object]
+MessageRole = str
 
 
 @pytest.fixture
 def app():
     """Create AICoder instance for testing"""
@@ -22,12 +25,12 @@
 
 @pytest.fixture
 def sample_messages():
     """Sample messages for testing"""
     return [
-        Message(role=MessageRole.USER, content="Hello"),
-        Message(role=MessageRole.ASSISTANT, content="Hi there!"),
+        {"role": "user", "content": "Hello"},
+        {"role": "assistant", "content": "Hi there!"},
     ]
 
 
 def test_aicoder_initialization(app):
     """Test AICoder initialization"""

Index: poc/aicoder/v3/tests/test_message_history.py
==================================================================
--- poc/aicoder/v3/tests/test_message_history.py
+++ poc/aicoder/v3/tests/test_message_history.py
@@ -8,16 +8,16 @@
     MessageHistory,
     PRUNED_TOOL_MESSAGE,
     PRUNE_PROTECTION_THRESHOLD,
 )
 from aicoder.core.stats import Stats
-from aicoder.type_defs.message_types import (
-    Message,
-    MessageRole,
-    AssistantMessage,
-    MessageToolCall,
-)
+
+# Type definitions are now dicts
+Message = dict[str, object]
+MessageRole = str
+AssistantMessage = dict[str, object]
+MessageToolCall = dict[str, object]
 
 
 @pytest.fixture
 def mock_tool_result():
     class ToolResult:

Index: poc/aicoder/v3/tests/test_stats.py
==================================================================
--- poc/aicoder/v3/tests/test_stats.py
+++ poc/aicoder/v3/tests/test_stats.py
@@ -2,11 +2,13 @@
 Test Stats class
 Tests to ensure exact behavior matches TypeScript version
 """
 
 from aicoder.core.stats import Stats
-from aicoder.type_defs.api_types import ApiUsage
+
+# Type definitions are now dicts
+ApiUsage = dict[str, int]
 
 
 def test_stats_initialization():
     """Test Stats initialization with all default values"""
     stats = Stats()
@@ -88,11 +90,11 @@
     # Test last user prompt
     stats.set_last_user_prompt("Hello world")
     assert stats.last_user_prompt == "Hello world"
 
     # Test usage info
-    usage = ApiUsage(prompt_tokens=10, completion_tokens=20, total_tokens=30)
+    usage = {"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30}
     stats.add_usage_info(usage)
     assert len(stats.usage_infos) == 1
     assert stats.usage_infos[0]["usage"] == usage
     assert "time" in stats.usage_infos[0]
 
@@ -104,11 +106,11 @@
     # Set some values
     stats.increment_api_requests()
     stats.add_api_time(1.0)
     stats.set_last_user_prompt("test")
     stats.add_usage_info(
-        ApiUsage(prompt_tokens=10, completion_tokens=20, total_tokens=30)
+        {"prompt_tokens": 10, "completion_tokens": 20, "total_tokens": 30}
     )
 
     # Reset
     stats.reset()
 

Index: poc/aicoder/v3/tests/test_token_estimator.py
==================================================================
--- poc/aicoder/v3/tests/test_token_estimator.py
+++ poc/aicoder/v3/tests/test_token_estimator.py
@@ -11,11 +11,13 @@
     set_tool_definitions_tokens,
     clear_token_cache,
     _message_token_cache,
     _last_tool_definitions_tokens,
 )
-from aicoder.type_defs.message_types import Message
+
+# Type definitions are now dicts
+Message = dict[str, object]
 
 
 def test_estimate_tokens_basic():
     """Test basic token estimation"""
     # Empty string

Index: poc/aicoder/v3/tests/utils/message_injector.py
==================================================================
--- poc/aicoder/v3/tests/utils/message_injector.py
+++ poc/aicoder/v3/tests/utils/message_injector.py
@@ -10,11 +10,13 @@
 
 from typing import Dict, List, Any, Optional
 from dataclasses import dataclass
 
 from aicoder.core.aicoder import AICoder
-from aicoder.type_defs.message_types import AssistantMessage as AICoderAssistantMessage
+
+# Type definitions are now dicts
+AICoderAssistantMessage = dict[str, object]
 
 
 @dataclass
 class ToolCall:
     """Represents a tool call from AI response."""
@@ -51,17 +53,17 @@
             
         Returns:
             List of tool execution results
         """
         self.executed_tools.clear()
-        
-        # Create AssistantMessage TypedDict for message_history
-        assistant_msg = AICoderAssistantMessage(
-            content=message.content,
-            tool_calls=[]
-        )
-        
+
+        # Create AssistantMessage dict for message_history
+        assistant_msg = {
+            "content": message.content,
+            "tool_calls": []
+        }
+
         # Add tool calls if present
         if message.tool_calls:
             tool_calls = []
             for tool_call in message.tool_calls:
                 # Convert to the format expected by AssistantMessage
@@ -99,23 +101,23 @@
         # Convert to internal format
         internal_tool_calls = []
         for tool_call in tool_calls:
             internal_tool_calls.append({
                 "id": tool_call.id,
-                "type": "function", 
+                "type": "function",
                 "function": {
                     "name": tool_call.function_name,
                     "arguments": tool_call.arguments
                 }
             })
-        
-        # Create AssistantMessage TypedDict
-        assistant_message = AICoderAssistantMessage(
-            content="",
-            tool_calls=internal_tool_calls
-        )
-        
+
+        # Create AssistantMessage dict
+        assistant_message = {
+            "content": "",
+            "tool_calls": internal_tool_calls
+        }
+
         # Add to message history using proper method
         self.aicoder.message_history.add_assistant_message(assistant_message)
         
         # Execute tools
         return self._execute_tool_calls(internal_tool_calls)
